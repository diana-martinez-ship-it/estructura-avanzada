<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoMarket: Seguridad en Sistemas Distribuidos - Autenticación con JWT en APIs</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
            border-bottom: 3px solid #e74c3c;
            padding-bottom: 10px;
        }
        .phase {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .phase h2 {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .phase h2::before {
            content: attr(data-icon);
            font-size: 1.5em;
            margin-right: 10px;
        }
        .activity {
            background: #e8f4fd;
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .checkpoint {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
        }
        .code-python {
            background: #f0f0f0;
            border-left: 4px solid #3572A5;
        }
        .code-csharp {
            background: #f0f0f0;
            border-left: 4px solid #9B4F96;
        }
        .code-nginx {
            background: #f0f0f0;
            border-left: 4px solid #A52A2A;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin: 5px 0;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .tip {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .reflection {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            background: white;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .comparison-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .ai-prompt {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
        }
        .progress-item {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: #e9ecef;
            margin: 0 5px;
            border-radius: 5px;
        }
        .progress-item.active {
            background: #e74c3c;
            color: white;
        }
        .scenario-box {
            background: #f0f8ff;
            border: 1px solid #e74c3c;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .diagram {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            overflow-x: auto;
        }
		footer p{
		  text-align:center;
		  font-size: 1.2em; 
		  color: #28a745;
		}
        .dual-lang {
            display: flex;
            gap: 20px;
        }
        .dual-lang > div {
            flex: 1;
        }
        @media (max-width: 768px) {
            .dual-lang {
                flex-direction: column;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({ startOnLoad: true, theme: 'default' });</script>
</head>
<body>
    <!-- Contexto del Curso -->
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
            <div>
                <h3 style="margin: 0; color: white;">📅 Semana 8 | Unidad IV: Seguridad en Sistemas Distribuidos (Parte 1)</h3>
                <p style="margin: 5px 0 0 0; opacity: 0.9;">Taller 7: Implementar Autenticación Basada en JWT</p>
            </div>
            <div style="text-align: right;">
                <p style="margin: 0; font-size: 0.9em; opacity: 0.9;">Duración: 4 horas</p>
                <p style="margin: 5px 0 0 0; font-size: 0.9em; opacity: 0.9;">Entrega: Hito 2 (15%)</p>
            </div>
        </div>
    </div>

    <h1>EcoMarket: Seguridad en Sistemas Distribuidos - Autenticación con JWT en APIs</h1>
    <p>De servicios expuestos sin protección a endpoints que solo aceptan peticiones autenticadas con JSON Web Tokens (JWT).</p>

    <!-- Sección de Introducción -->
    <section id="introduccion" style="background: #f0f8ff; border-radius: 10px; padding: 20px; margin: 20px 0;">
        <h2>🎯 Al Final de Esta Semana (Unidad IV, Parte 1), Serás Capaz De:</h2>
        <div class="checkpoint">
            <ul>
                <li>✅ <strong>Explicar</strong> los fundamentos teóricos de JWT y su papel en autenticación y autorización en APIs.</li>
                <li>✅ <strong>Diferenciar</strong> entre autenticación basada en sesiones y autenticación stateless con tokens.</li>
                <li>✅ <strong>Diseñar</strong> el flujo de autenticación de EcoMarket usando JWT (login, refresh, expiración).</li>
                <li>✅ <strong>Implementar</strong> protección de endpoints en tu backend usando JWT (middleware/filters).</li>
                <li>✅ <strong>Aplicar</strong> buenas prácticas de seguridad: firmas, expiración, almacenamiento seguro, scopes/roles.</li>
                <li>✅ <strong>Probar</strong> tu API con y sin token para demostrar que solo acepta peticiones válidas.</li>
            </ul>
        </div>

        <h2>📚 Lecturas / Estudio Independiente (Antes del Taller 7)</h2>
        <p>Dedica 30–45 minutos a las siguientes lecturas introductorias:</p>
        <ul>
            <li>Conceptos oficiales de <strong>JSON Web Token (RFC 7519)</strong>: estructura, encabezado, payload y firma.</li>
            <li>Artículo o documentación de tu framework favorito (FastAPI, ASP.NET, Spring, etc.) sobre autenticación con JWT.</li>
            <li>Material de referencia interno del curso sobre <strong>Seguridad en Sistemas Distribuidos</strong> y amenazas típicas (replay, robo de tokens, CSRF, XSS).</li>
        </ul>

        <h2>🛠️ Taller 7: Implementar Autenticación Basada en JWT en EcoMarket</h2>
        <p><strong>Duración sugerida:</strong> 4 horas (trabajo en laboratorio).</p>
        <p><strong>Objetivo del Taller:</strong> Transformar tu API de EcoMarket (usada en semanas anteriores) para que todos los endpoints sensibles requieran un JWT válido firmado por tu servidor.</p>

        <ol>
            <li>Agregar un endpoint de <strong>login</strong> que valide credenciales y genere un token JWT.</li>
            <li>Implementar un <strong>middleware o filtro</strong> que:
                <ul>
                    <li>Lea el token del encabezado <code>Authorization: Bearer &lt;token&gt;</code>.</li>
                    <li>Verifique la firma y expiración.</li>
                    <li>Inyecte la identidad/roles del usuario al contexto de la petición.</li>
                </ul>
            </li>
            <li>Proteger endpoints clave de EcoMarket (por ejemplo, crear/actualizar productos, ver carrito, generar órdenes).</li>
            <li>Probar manualmente y con herramientas (Postman, curl) que:
                <ul>
                    <li>Sin token → acceso denegado (HTTP 401 / 403).</li>
                    <li>Con token expirado o manipulado → acceso denegado.</li>
                    <li>Con token válido → acceso permitido.</li>
                </ul>
            </li>
        </ol>

        <h3>Requisitos Técnicos Mínimos</h3>
        <ul>
            <li>Backend en Python (FastAPI/Flask/Django) o C# (.NET) reutilizando tu proyecto de semanas 5–7.</li>
            <li>Librería de JWT (por ejemplo, <code>pyjwt</code> en Python o <code>System.IdentityModel.Tokens.Jwt</code> en .NET).</li>
            <li>Clave secreta segura almacenada como variable de entorno y <strong>no</strong> hardcodeada en el repositorio.</li>
            <li>Postman o herramienta similar para enviar peticiones HTTP con encabezados personalizados.</li>
        </ul>

        <div class="tip">
            <h3>🔐 ¿Por Qué JWT en Sistemas Distribuidos?</h3>
            <ul>
                <li><strong>Stateless:</strong> No necesitas mantener sesiones en servidor; ideal para microservicios distribuidos.</li>
                <li><strong>Escalable:</strong> Cualquier servicio que conozca la clave o llave pública puede validar el token.</li>
                <li><strong>Flexible:</strong> Puedes incluir claims: roles, permisos, tenant, caducidad, etc.</li>
                <li><strong>Interoperable:</strong> Funciona bien con gateways, API managers y diferentes lenguajes.</li>
            </ul>
            <p><strong>Advertencia:</strong> JWT no es mágico: si el secreto se filtra o gestionas mal la expiración, abres la puerta a ataques serios.</p>
        </div>

        <h3>📊 Esquema de Componentes Propuesto (JWT en EcoMarket)</h3>
        <div class="diagram">
            <div class="mermaid">
sequenceDiagram
    participant C as Cliente
    participant A as Auth Service
    participant API as API EcoMarket
    participant DB as Base de Datos

    Note over C,DB: FASE 1: LOGIN Y OBTENCIÓN DE TOKEN
    C->>A: POST /login {email, password}
    A->>DB: Verificar credenciales
    DB-->>A: Usuario válido + rol
    A->>A: Generar JWT con claims<br/>{sub, role, exp, iat}
    A-->>C: 200 OK {access_token: "eyJ..."}
    
    Note over C: Cliente guarda token en memoria
    
    Note over C,API: FASE 2: USO DEL TOKEN EN PETICIONES
    C->>API: GET /productos/123<br/>Authorization: Bearer eyJ...
    API->>API: Middleware verifica<br/>firma y expiración
    alt Token válido
        API->>DB: Consultar producto
        DB-->>API: Datos del producto
        API-->>C: 200 OK {producto}
    else Token expirado/inválido
        API-->>C: 401 Unauthorized
        Note over C: Redirigir a /login
    end
            </div>
            <p><em>Diagrama Mermaid: flujo básico de login, emisión y validación de JWT en la arquitectura de EcoMarket.</em></p>
        </div>

        <h2>📋 Entrega y Evaluación (Entrega Hito 2 - Servicios con Seguridad, 15%)</h2>
        <ul>
            <li><strong>Repositorio:</strong> Código del backend con autenticación JWT integrada y documentación en README.</li>
            <li><strong>Diagrama:</strong> Flujo de autenticación/autorización con JWT en tu arquitectura distribuida.</li>
            <li><strong>Video corto (1–2 min):</strong> Demostración E2E:
                <ul>
                    <li>Login exitoso → obtención de token.</li>
                    <li>Llamada a endpoint protegido sin token (falla).</li>
                    <li>Llamada con token válido (éxito).</li>
                </ul>
            </li>
            <li><strong>Informe breve (1–2 páginas):</strong>
                <ul>
                    <li>Justificación de por qué JWT es adecuado para EcoMarket.</li>
                    <li>Descripción de los claims usados (sub, role, exp, etc.).</li>
                    <li>Buenas prácticas implementadas y riesgos identificados.</li>
                </ul>
            </li>
        </ul>

        <div class="tip">
            <strong>Tip para la entrega:</strong> Incluye ejemplos de peticiones HTTP (curl/Postman) en el README y, si puedes, un archivo de colección para importar en Postman.
        </div>

        <div style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h3 style="margin-top: 0; color: white;">✅ Checklist de Entrega - Hito 2 (15%)</h3>
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 5px;">
                <table style="width: 100%; color: white;">
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.3);">
                            <input type="checkbox" style="margin-right: 10px;">
                            <strong>Repositorio GitHub/GitLab</strong> con código funcional y README actualizado
                        </td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.3);">
                            <input type="checkbox" style="margin-right: 10px;">
                            <strong>Endpoint /login</strong> que genera y devuelve JWT válido
                        </td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.3);">
                            <input type="checkbox" style="margin-right: 10px;">
                            <strong>Middleware/filtro JWT</strong> protegiendo al menos 3 endpoints críticos
                        </td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.3);">
                            <input type="checkbox" style="margin-right: 10px;">
                            <strong>Diagrama de arquitectura</strong> mostrando flujo de autenticación JWT
                        </td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.3);">
                            <input type="checkbox" style="margin-right: 10px;">
                            <strong>Video de demostración (1-2 min)</strong>: login exitoso, request sin token (falla), request con token (éxito)
                        </td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.3);">
                            <input type="checkbox" style="margin-right: 10px;">
                            <strong>Informe técnico (1-2 páginas)</strong>: justificación JWT, claims usados, buenas prácticas
                        </td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.3);">
                            <input type="checkbox" style="margin-right: 10px;">
                            <strong>Colección Postman/Thunder Client</strong> con ejemplos de peticiones
                        </td>
                    </tr>
                    <tr>
                        <td style="padding: 8px;">
                            <input type="checkbox" style="margin-right: 10px;">
                            <strong>Tests automatizados</strong> (mínimo 3: token válido, expirado, manipulado)
                        </td>
                    </tr>
                </table>
            </div>
            <p style="margin-bottom: 0; margin-top: 15px; opacity: 0.9;">
                <strong>Fecha de entrega:</strong> Consultar calendario del curso | 
                <strong>Plataforma:</strong> Google Classroom
            </p>
        </div>
    </section>

    <div id="journey"></div>

    <div class="progress-bar">
        <div class="progress-item active">🎯 Fase 0: El Problema</div>
        <div class="progress-item">🧩 Fase 1: Fundamentos JWT</div>
        <div class="progress-item">💾 Fase 1.5: Almacenamiento</div>
        <div class="progress-item">💻 Fase 2: Implementación</div>
        <div class="progress-item">🧪 Fase 3: Pruebas</div>
    </div>

    <!-- Fase 0 -->
    <div class="phase">
        <h2 data-icon="🎯">Fase 0: El Problema Real de Exponer APIs sin Autenticación (30 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Comprender por qué una API sin autenticación ni autorización es un riesgo crítico en sistemas distribuidos.</p>

        <div class="scenario-box">
            <h3>🪴 Escenario: EcoMarket Antes de JWT</h3>
            <p>Tu backend de EcoMarket ya está distribuido y escalable (semana 7), pero muchos endpoints siguen abiertos:</p>
            <ul>
                <li><strong>GET /productos</strong> – Público, sin restricciones.</li>
                <li><strong>POST /productos</strong> – Cualquiera puede crear productos falsos.</li>
                <li><strong>POST /ordenes</strong> – Cualquiera puede generar órdenes y saturar el sistema.</li>
                <li><strong>DELETE /usuarios/{id}</strong> – Sin control de roles.</li>
            </ul>
            <p>Un atacante puede escribir un script que automatice peticiones y cause desde fraudes hasta denegación de servicio lógica.</p>
        </div>

        <div class="diagram">
            <div class="mermaid">
graph TB
    A[👤 Cliente Legítimo] -->|POST /productos| B[API EcoMarket<br/>SIN AUTENTICACIÓN]
    C[🦹 Atacante] -->|POST /productos<br/>datos falsos| B
    D[🤖 Bot] -->|DELETE /usuarios/123| B
    E[👾 Script] -->|POST /ordenes<br/>saturación| B
    
    B -->|❌ Acepta todo| F[(Base de Datos)]
    
    F --> G[❌ Productos falsos]
    F --> H[❌ Usuarios eliminados]
    F --> I[❌ Sistema saturado]
    
    style B fill:#f8d7da
    style F fill:#f8d7da
    style G fill:#f8d7da
    style H fill:#f8d7da
    style I fill:#f8d7da
            </div>
            <p><em>Sin autenticación, la API no distingue entre cliente legítimo y atacante.</em></p>
        </div>

        <div class="warning">
            <h3>🔥 Riesgos Concretos</h3>
            <ul>
                <li><strong>Fraude:</strong> Creación masiva de productos/órdenes falsas</li>
                <li><strong>Data Breach:</strong> Lectura de datos sensibles de otros usuarios</li>
                <li><strong>DoS Lógico:</strong> Saturación de recursos por abuso de endpoints</li>
                <li><strong>Imposibilidad de auditoría:</strong> No se puede rastrear "quién hizo qué"</li>
                <li><strong>Violación de compliance:</strong> GDPR/SOC2 requieren trazabilidad</li>
            </ul>
        </div>

        <div class="warning">
            <h3>⚠️ Síntomas de Falta de Seguridad</h3>
            <ul>
                <li>La API no distingue entre un cliente legítimo y un script malicioso.</li>
                <li>No hay manera confiable de registrar acciones por usuario.</li>
                <li>No es posible aplicar reglas de negocio por rol (admin, vendedor, cliente).</li>
            </ul>
        </div>

        <div class="activity">
            <h3>🧮 Actividad: Mapear Endpoints Críticos</h3>
            <ol>
                <li>Enlista todos los endpoints de tu API actual.</li>
                <li>Clasifícalos en: públicos, autenticados, solo admin.</li>
                <li>Marca con un ❌ aquellos que hoy están desprotegidos pero no deberían estarlo.</li>
            </ol>
            <p><strong>Producto:</strong> Tabla de endpoints con columna “¿Requiere JWT?”</p>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt para IA: Análisis de Riesgos en mi API</h4>
            <pre>Analiza la siguiente API de EcoMarket desde la perspectiva de seguridad:

Endpoints:
- GET /productos
- POST /productos
- POST /ordenes
- DELETE /usuarios/{id}
- GET /usuarios/me

Contexto:
- Actualmente sin autenticación.
- Se planea usar JWT para proteger endpoints.

Preguntas:
1. ¿Qué riesgos concretos existen si sigo sin autenticación?
2. ¿Cuáles endpoints deberían ser públicos y cuáles requieren JWT?
3. ¿Qué roles mínimos sugieres (admin, vendedor, cliente, etc.)?
4. ¿Qué tipo de ataques serían más probables (abuso de API, fraude, etc.)?</pre>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint Fase 0</h3>
            <ul>
                <li>Tengo listado de endpoints y su nivel de riesgo.</li>
                <li>Identifiqué endpoints que deben requerir JWT.</li>
                <li>Puedo explicar por qué necesito autenticación fuerte en un sistema distribuido.</li>
            </ul>
        </div>
    </div>

    <!-- Fase 1 -->
    <div class="phase">
        <h2 data-icon="🧩">Fase 1: Fundamentos Teóricos de JWT (45 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Comprender la estructura, propiedades matemáticas y roles de un JWT en autenticación y autorización.</p>

        <h3>📦 Estructura de un JWT</h3>
        <div class="diagram">
JWT = header.payload.signature

header:  {"alg": "HS256", "typ": "JWT"}
payload: {"sub": "usuario123", "role": "admin", "exp": 1735689600}
firma:   HMACSHA256(
           base64UrlEncode(header) + "." +
           base64UrlEncode(payload),
           clave_secreta
         )
        </div>

        <div class="warning">
            <h3>⚠️ CRÍTICO: JWT NO Está Cifrado</h3>
            <p>El payload de un JWT está en <strong>Base64URL</strong>, no cifrado. Cualquiera puede decodificarlo con herramientas como jwt.io.</p>
            <p><strong>❌ NUNCA incluyas:</strong></p>
            <ul>
                <li>Contraseñas</li>
                <li>Números de tarjetas de crédito</li>
                <li>Información médica o financiera sensible</li>
                <li>Datos personales protegidos por GDPR/LFPDPPP</li>
            </ul>
            <p><strong>✅ SÍ puedes incluir:</strong></p>
            <ul>
                <li>ID de usuario (sub)</li>
                <li>Roles/permisos</li>
                <li>Preferencias no sensibles</li>
                <li>Metadatos públicos del usuario</li>
            </ul>
        </div>

        <h3>📋 Claims Estándar (RFC 7519)</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Claim</th>
                    <th>Significado</th>
                    <th>¿Obligatorio?</th>
                    <th>Ejemplo en EcoMarket</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>sub</code></td>
                    <td>Subject (ID único e inmutable del usuario)</td>
                    <td><strong>Recomendado</strong></td>
                    <td>"user_12345"</td>
                </tr>
                <tr>
                    <td><code>iss</code></td>
                    <td>Issuer (quién emitió el token)</td>
                    <td>Recomendado</td>
                    <td>"ecomarket-auth-service"</td>
                </tr>
                <tr>
                    <td><code>aud</code></td>
                    <td>Audience (para quién es el token)</td>
                    <td>Recomendado</td>
                    <td>"ecomarket-api"</td>
                </tr>
                <tr>
                    <td><code>exp</code></td>
                    <td>Expiration time (Unix timestamp)</td>
                    <td><strong>Obligatorio</strong></td>
                    <td>1735689600</td>
                </tr>
                <tr>
                    <td><code>iat</code></td>
                    <td>Issued At (cuándo se emitió)</td>
                    <td>Recomendado</td>
                    <td>1735686000</td>
                </tr>
                <tr>
                    <td><code>nbf</code></td>
                    <td>Not Before (válido desde)</td>
                    <td>Opcional</td>
                    <td>1735686000</td>
                </tr>
                <tr>
                    <td><code>jti</code></td>
                    <td>JWT ID (identificador único para revocación)</td>
                    <td>Opcional</td>
                    <td>"jwt_abc123xyz"</td>
                </tr>
            </tbody>
        </table>

        <div class="activity">
            <h3>🔬 Actividad Práctica: Decodifica un JWT a Mano</h3>
            <p>Toma este JWT de ejemplo:</p>
            <code style="word-break: break-all; background: #f8f9fa; padding: 10px; display: block; border-radius: 5px;">
            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c3VhcmlvMTIzIiwicm9sZSI6ImFkbWluIiwiZXhwIjoxNzM1Njg5NjAwfQ.X8vL3kJp9YwN4R6cXtBnH2mQ1oP7Z5
            </code>
            
            <ol>
                <li>Copia las <strong>dos primeras secciones</strong> (antes del segundo punto).</li>
                <li>Usa un decodificador Base64 online (<a href="https://www.base64decode.org/" target="_blank">base64decode.org</a>) o jwt.io.</li>
                <li>Decodifica <strong>header</strong>: ¿Qué algoritmo usa?</li>
                <li>Decodifica <strong>payload</strong>: ¿Qué rol tiene el usuario? ¿Cuándo expira? (convierte el timestamp Unix)</li>
                <li>Intenta decodificar la <strong>firma</strong>: ¿Qué obtienes? (Pista: datos binarios ilegibles)</li>
            </ol>
            
            <div class="checkpoint">
                <p><strong>Conclusión:</strong> Header y payload son <strong>legibles</strong> (solo Base64), la firma es <strong>criptográfica</strong> (verificable pero no reversible sin la clave secreta).</p>
            </div>
        <h3>📐 Propiedades Matemáticas y su Impacto en el Rendimiento</h3>
        <ul>
            <li>La firma se calcula con algoritmos de hash criptográfico (HMAC-SHA256, RS256, etc.).</li>
            <li>Verificar un token requiere:
                <ul>
                    <li>Recalcular la firma con la clave secreta o llave pública.</li>
                    <li>Comparar la firma recibida con la calculada.</li>
                </ul>
            </li>
            <li>La complejidad es <em>O(n)</em> respecto al tamaño del token, pero los algoritmos están optimizados.</li>
            <li>En sistemas distribuidos, el costo se paga en cada petición, por lo que:
                <ul>
                    <li>Tokens muy grandes → más bytes por petición → más latencia.</li>
                    <li>Algoritmos asimétricos (RS256) → más seguros pero algo más pesados que HMAC.</li>
                </ul>
            </li>
        </ul>

        <div class="comparison-table">
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Atributo</th>
                        <th>HMAC (HS256)</th>
                        <th>RSA (RS256)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Tipo de clave</td>
                        <td>Simétrica (misma clave)</td>
                        <td>Asimétrica (privada/pública)</td>
                    </tr>
                    <tr>
                        <td>Rendimiento</td>
                        <td>Más rápido</td>
                        <td>Más pesado</td>
                    </tr>
                    <tr>
                        <td>Escenario típico</td>
                        <td>Un solo emisor/validador</td>
                        <td>Varios servicios validan con llave pública</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt para IA: Elegir Algoritmo para JWT</h4>
            <pre>Quiero usar JWT en una arquitectura de microservicios:

Contexto:
- Un servicio central emite tokens.
- Varios servicios distribuidos validan tokens.
- No quiero compartir claves simétricas con todos.

Preguntas:
1. ¿Qué algoritmo de firma recomiendas (HS256 vs RS256 u otros)?
2. ¿Qué impacto tiene en rendimiento y seguridad?
3. ¿Cómo debería gestionar las claves (rotación, almacenamiento seguro)?</pre>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint Fase 1</h3>
            <ul>
                <li>Puedo explicar la estructura interna de un JWT.</li>
                <li>Entiendo la diferencia entre token firmado y token cifrado.</li>
                <li>Comprendo el impacto de los algoritmos de firma en rendimiento y seguridad.</li>
                <li>Sé cuándo usar claves simétricas y cuándo asimétricas.</li>
            </ul>
        </div>
    </div>

    <!-- Fase 1.5: Almacenamiento del Token -->
    <div class="phase" style="background: #fff3cd; border-left: 4px solid #ffc107;">
        <h2 data-icon="💾">Almacenamiento Seguro del Token en el Cliente</h2>
        
        <div class="warning">
            <h3>⚠️ ¿Dónde Guarda el Cliente el JWT?</h3>
            <p>Esta decisión tiene <strong>implicaciones críticas de seguridad</strong>. Cada método tiene trade-offs:</p>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Ventajas</th>
                        <th>Desventajas</th>
                        <th>Recomendación</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>localStorage</strong></td>
                        <td>
                            • Fácil de implementar<br>
                            • Persiste entre sesiones<br>
                            • Accesible desde JavaScript
                        </td>
                        <td>
                            • <strong>Vulnerable a XSS</strong><br>
                            • Cualquier script puede leerlo<br>
                            • No hay expiración automática
                        </td>
                        <td>⚠️ Solo para apps de bajo riesgo</td>
                    </tr>
                    <tr>
                        <td><strong>Memoria (variable JS)</strong></td>
                        <td>
                            • <strong>Inmune a XSS</strong><br>
                            • Se limpia al cerrar pestaña<br>
                            • No persiste si no debe
                        </td>
                        <td>
                            • No persiste al recargar<br>
                            • Re-login frecuente<br>
                            • Complica la UX
                        </td>
                        <td>✅ Combinado con refresh en cookie</td>
                    </tr>
                    <tr>
                        <td><strong>httpOnly Cookie</strong></td>
                        <td>
                            • <strong>JavaScript NO puede acceder</strong><br>
                            • Inmune a XSS<br>
                            • Manejado por navegador<br>
                            • Auto-enviado en peticiones
                        </td>
                        <td>
                            • Vulnerable a CSRF (mitigar con SameSite)<br>
                            • Más complejo de implementar<br>
                            • Requiere configuración de cookies
                        </td>
                        <td>✅✅ <strong>Mejor opción</strong> para producción</td>
                    </tr>
                </tbody>
            </table>
            
            <h4>🎯 Recomendación para EcoMarket</h4>
            <ul>
                <li><strong>Access token</strong> (vida corta: 15-30 min) → Memoria (variable JavaScript)</li>
                <li><strong>Refresh token</strong> (vida larga: 7 días) → httpOnly cookie con SameSite=Strict</li>
                <li>Esto combina <strong>seguridad</strong> (inmunidad a XSS) con <strong>buena UX</strong> (refresh automático)</li>
            </ul>
        </div>

        <div class="tip">
            <h3>🌐 JWT y CORS: Configuración Necesaria</h3>
            <p>Si tu frontend está en <code>localhost:3000</code> y el backend en <code>localhost:8000</code>, necesitas configurar CORS para permitir el header <code>Authorization</code>.</p>
            
            <h4>Ejemplo en Python (FastAPI):</h4>
            <div class="code-block code-python">
<pre>from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://ecomarket.com"],
    allow_credentials=True,  # Permite cookies
    allow_methods=["*"],
    allow_headers=["*"],  # Incluye Authorization
)</pre>
            </div>

            <h4>Ejemplo en C# (.NET):</h4>
            <div class="code-block code-csharp">
<pre>builder.Services.AddCors(options =>
{
    options.AddPolicy("EcoMarketPolicy", policy =>
    {
        policy.WithOrigins("http://localhost:3000", "https://ecomarket.com")
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

app.UseCors("EcoMarketPolicy");</pre>
            </div>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint: Almacenamiento</h3>
            <ul>
                <li>Entiendo los riesgos de localStorage vs httpOnly cookies.</li>
                <li>Conozco la estrategia de "access token en memoria + refresh en cookie".</li>
                <li>Configuré CORS correctamente para permitir headers de autorización.</li>
            </ul>
        </div>
    </div>

    <!-- Fase 2 -->
    <div class="phase">
        <h2 data-icon="💻">Fase 2: Implementando Autenticación con JWT en Código (90 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Implementar paso a paso autenticación y autorización basada en JWT en tu API.</p>

        <h3>🧪 Paso 1: Generar Tokens en el Endpoint de Login</h3>

        <div class="dual-lang">
            <div>
                <h4>Ejemplo en Python (FastAPI + PyJWT)</h4>
                <div class="code-block code-python">
<pre>import jwt
import os
from datetime import datetime, timedelta, timezone

SECRET_KEY = os.getenv("JWT_SECRET", "cambia_esto_por_un_secreto_seguro")
ALGORITHM = "HS256"

def crear_token(usuario_id: str, rol: str):
    ahora = datetime.now(timezone.utc)
    payload = {
        "sub": usuario_id,
        "role": rol,
        "iss": "ecomarket-auth-service",  # Emisor
        "aud": "ecomarket-api",  # Audiencia
        "iat": ahora,
        "exp": ahora + timedelta(minutes=30),
        "jti": str(uuid.uuid4())  # ID único para revocación
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    return token

@app.post("/login")
def login(credenciales: Credenciales):
    usuario = autenticar_usuario(credenciales)
    if not usuario:
        raise HTTPException(status_code=401, detail="Credenciales inválidas")
    token = crear_token(usuario.id, usuario.rol)
    return {"access_token": token, "token_type": "bearer"}</pre>
                </div>
            </div>
            <div>
                <h4>Ejemplo en C# (.NET + JWT)</h4>
                <div class="code-block code-csharp">
<pre>public string CrearToken(AppUser user)
{
    var claims = new List&lt;Claim&gt;
    {
        new Claim(JwtRegisteredClaimNames.Sub, user.Id),
        new Claim(ClaimTypes.Role, user.Role),
        new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
    };

    var key = new SymmetricSecurityKey(
        Encoding.UTF8.GetBytes(_config["Jwt:Secret"])
    );
    var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

    var token = new JwtSecurityToken(
        issuer: _config["Jwt:Issuer"],
        audience: _config["Jwt:Audience"],
        claims: claims,
        expires: DateTime.UtcNow.AddMinutes(30),
        signingCredentials: creds
    );

    return new JwtSecurityTokenHandler().WriteToken(token);
}</pre>
                </div>
            </div>
        </div>

        <h3>🛡️ Paso 2: Middleware / Filter para Validar Tokens</h3>

        <div class="dual-lang">
            <div>
                <h4>Middleware en Python</h4>
                <div class="code-block code-python">
<pre>from fastapi import Request, HTTPException

async def verificar_jwt(request: Request, call_next):
    # Rutas públicas que no requieren token
    rutas_publicas = ["/login", "/register", "/docs", "/openapi.json"]
    if any(request.url.path.startswith(ruta) for ruta in rutas_publicas):
        return await call_next(request)

    auth = request.headers.get("Authorization")
    if not auth or not auth.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Token requerido")

    token = auth.split(" ")[1]
    try:
        # Validar firma, algoritmo y expiración
        payload = jwt.decode(
            token, 
            SECRET_KEY, 
            algorithms=[ALGORITHM],
            options={"verify_signature": True}  # Forzar verificación
        )
        
        # Validar claims obligatorios
        if not payload.get("sub"):
            raise HTTPException(status_code=401, detail="Token sin subject")
        
        # Inyectar usuario en contexto
        request.state.user_id = payload.get("sub")
        request.state.role = payload.get("role")
        request.state.user_data = payload
        
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expirado")
    except jwt.InvalidSignatureError:
        raise HTTPException(status_code=401, detail="Firma inválida")
    except jwt.InvalidTokenError as e:
        raise HTTPException(status_code=401, detail=f"Token inválido: {str(e)}")

    response = await call_next(request)
    return response</pre>
                </div>
            </div>
            <div>
                <h4>Filtros y Atributos en .NET</h4>
                <div class="code-block code-csharp">
<pre>[Authorize(Roles = "Admin")]
[ApiController]
[Route("api/[controller]")]
public class ProductosController : ControllerBase
{
    [HttpPost]
    public IActionResult CrearProducto(NuevoProducto dto)
    {
        // Si el token no es válido o no tiene rol Admin, nunca llega aquí.
        ...
    }
}</pre>
                </div>
            </div>
        </div>

        <div class="activity">
            <h3>Actividad: Proteger Endpoints Críticos</h3>
            <ol>
                <li>Identifica 3–5 endpoints de alto impacto en EcoMarket.</li>
                <li>Protégelos con tu middleware/filtro de JWT.</li>
                <li>Define qué roles pueden acceder a cada endpoint (por ejemplo, admin, vendedor, cliente).</li>
                <li>Prueba distintos escenarios:
                    <ul>
                        <li>Sin encabezado <code>Authorization</code>.</li>
                        <li>Con token manipulado.</li>
                        <li>Con token válido pero sin rol adecuado.</li>
                    </ul>
                </li>
            </ol>
        </div>

        <div class="tip">
            <p><strong>Buenas prácticas:</strong></p>
            <ul>
                <li>Define tiempos de expiración razonables (tokens muy largos aumentan el riesgo).</li>
                <li>No coloques datos sensibles (como contraseñas) en el payload del JWT.</li>
                <li>Almacena la clave secreta en variables de entorno o un gestor de secretos.</li>
                <li>Implementa rotación de claves para mitigar compromisos de seguridad.</li>
            </ul>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint Fase 2</h3>
            <ul>
                <li>Mi API ya emite tokens JWT en el login.</li>
                <li>Los endpoints críticos solo aceptan peticiones con token válido.</li>
                <li>El middleware/filtro maneja expiración y tokens inválidos.</li>
                <li>Tengo pruebas básicas con Postman o scripts para verificar el flujo.</li>
            </ul>
        </div>

        <h3>🔄 Paso 3: Implementar Refresh Tokens (Recomendado)</h3>
        
        <div class="tip">
            <p><strong>Problema:</strong> Si tu access token expira en 30 minutos, el usuario debe hacer login cada media hora. 😤</p>
            <p><strong>Solución:</strong> Usa un <strong>refresh token</strong> de vida larga (7 días) almacenado de forma segura para obtener nuevos access tokens sin re-autenticación.</p>
        </div>

        <div class="diagram">
ESTRATEGIA DE TOKENS DUAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌─────────────────────────────────────────────────────────┐
│ Access Token (corto: 15-30 min)                        │
│ ─────────────────────────────────────────────────────── │
│ • Usado en CADA petición a la API                      │
│ • Si se roba, daño limitado a 30 minutos               │
│ • Claims: sub, role, exp, iat, iss, aud                │
│ • Almacenado en memoria (inmune a XSS)                 │
└─────────────────────────────────────────────────────────┘
                            +
┌─────────────────────────────────────────────────────────┐
│ Refresh Token (largo: 7-30 días)                       │
│ ─────────────────────────────────────────────────────── │
│ • Solo usado en /refresh endpoint                      │
│ • Almacenado en httpOnly cookie (más seguro)           │
│ • Puede revocarse en base de datos                     │
│ • Claims: sub, jti (para rastreo), exp                 │
└─────────────────────────────────────────────────────────┘

FLUJO:
1. Login → Devuelve AMBOS tokens
2. Cliente usa access token en cada request
3. Cuando access expira (401) → Cliente llama /refresh
4. /refresh valida refresh token → Devuelve NUEVO access token
5. Si refresh expira → Re-login necesario
        </div>

        <div class="dual-lang">
            <div>
                <h4>Python: Endpoint de Refresh</h4>
                <div class="code-block code-python">
<pre>import uuid
from datetime import datetime, timedelta, timezone

# Tabla en BD para refresh tokens activos (simplificada)
refresh_tokens_db = {}  # En producción: Redis o tabla SQL

def crear_refresh_token(usuario_id: str):
    """Genera un refresh token de larga duración"""
    jti = str(uuid.uuid4())
    ahora = datetime.now(timezone.utc)
    payload = {
        "sub": usuario_id,
        "jti": jti,
        "type": "refresh",
        "iat": ahora,
        "exp": ahora + timedelta(days=7)
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    
    # Guardar en BD para poder revocar
    refresh_tokens_db[jti] = {
        "usuario_id": usuario_id,
        "creado": ahora,
        "revocado": False
    }
    
    return token

@app.post("/login")
def login(credenciales: Credenciales):
    usuario = autenticar_usuario(credenciales)
    if not usuario:
        raise HTTPException(status_code=401, detail="Credenciales inválidas")
    
    # Generar AMBOS tokens
    access_token = crear_token(usuario.id, usuario.rol)
    refresh_token = crear_refresh_token(usuario.id)
    
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "expires_in": 1800  # 30 minutos
    }

@app.post("/refresh")
def refresh_access_token(refresh_token: str):
    """Genera un nuevo access token usando el refresh token"""
    try:
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        
        # Verificar que sea un refresh token
        if payload.get("type") != "refresh":
            raise HTTPException(status_code=401, detail="Token inválido")
        
        # Verificar que no haya sido revocado
        jti = payload.get("jti")
        if jti not in refresh_tokens_db or refresh_tokens_db[jti]["revocado"]:
            raise HTTPException(status_code=401, detail="Refresh token revocado")
        
        # Obtener datos del usuario
        usuario_id = payload["sub"]
        usuario = obtener_usuario(usuario_id)
        
        # Generar NUEVO access token
        nuevo_access = crear_token(usuario.id, usuario.rol)
        
        return {
            "access_token": nuevo_access,
            "token_type": "bearer",
            "expires_in": 1800
        }
        
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401, 
            detail="Refresh token expirado, re-login necesario"
        )
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Refresh token inválido")

@app.post("/logout")
def logout(refresh_token: str):
    """Revoca el refresh token (logout seguro)"""
    try:
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        jti = payload.get("jti")
        
        if jti in refresh_tokens_db:
            refresh_tokens_db[jti]["revocado"] = True
            
        return {"message": "Logout exitoso"}
    except:
        return {"message": "Logout procesado"}</pre>
                </div>
            </div>
            <div>
                <h4>C#: Endpoint de Refresh</h4>
                <div class="code-block code-csharp">
<pre>[HttpPost("refresh")]
public IActionResult RefreshToken([FromBody] string refreshToken)
{
    try
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_config["Jwt:Secret"]);
        
        // Validar refresh token
        tokenHandler.ValidateToken(refreshToken, new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidIssuer = _config["Jwt:Issuer"],
            ValidAudience = _config["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(key)
        }, out SecurityToken validatedToken);

        var jwtToken = (JwtSecurityToken)validatedToken;
        var userId = jwtToken.Claims.First(x => x.Type == "sub").Value;
        
        // Verificar que no esté revocado (consultar BD)
        if (_refreshTokenService.IsRevoked(jwtToken.Id))
            return Unauthorized("Refresh token revocado");

        // Obtener usuario y generar nuevo access token
        var user = _userService.GetById(userId);
        var newAccessToken = CrearToken(user);

        return Ok(new { access_token = newAccessToken });
    }
    catch (SecurityTokenExpiredException)
    {
        return Unauthorized("Refresh token expirado");
    }
    catch
    {
        return Unauthorized("Refresh token inválido");
    }
}</pre>
                </div>
            </div>
        </div>

        <div class="activity">
            <h3>Actividad: Implementa Refresh Tokens en EcoMarket</h3>
            <ol>
                <li>Modifica tu endpoint <code>/login</code> para devolver <strong>ambos</strong> tokens (access y refresh).</li>
                <li>Crea una tabla en BD para rastrear refresh tokens activos:
                    <ul>
                        <li>Campos: id, jti, usuario_id, creado, expira, revocado</li>
                    </ul>
                </li>
                <li>Implementa <code>/refresh</code> que:
                    <ul>
                        <li>Valide el refresh token</li>
                        <li>Verifique que no esté revocado</li>
                        <li>Genere un nuevo access token</li>
                    </ul>
                </li>
                <li>Implementa <code>/logout</code> que revoque el refresh token.</li>
                <li>En el frontend, intercepta errores 401 y llama automáticamente a <code>/refresh</code>.</li>
            </ol>
        </div>

        <div class="warning">
            <h3>⚠️ Consideraciones de Seguridad con Refresh Tokens</h3>
            <ul>
                <li><strong>Rotación:</strong> Considera emitir un NUEVO refresh token con cada uso (rotation) para detectar robo.</li>
                <li><strong>Revocación:</strong> Debes poder revocar refresh tokens (logout, cambio de contraseña, sospecha).</li>
                <li><strong>Límites:</strong> Un usuario debería tener máximo N refresh tokens activos (e.g., 5 dispositivos).</li>
                <li><strong>Auditoría:</strong> Registra cada uso de refresh tokens para detectar patrones anómalos.</li>
            </ul>
        </div>
    </div>

    <!-- Fase 3 -->
    <div class="phase">
        <h2 data-icon="🧪">Fase 3: Pruebas, Ataques Comunes y Endurecimiento (30 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Validar que tu implementación de JWT resiste casos comunes de abuso y se integra adecuadamente en tu sistema distribuido.</p>

        <div class="activity">
            <h3>🔥 Pruebas Recomendadas</h3>
            <ol>
                <li><strong>Token expirado:</strong>
                    <ul>
                        <li>Genera un token con <code>exp</code> muy corto (1 minuto).</li>
                        <li>Después de la expiración, verifica que la API responda 401.</li>
                    </ul>
                </li>
                <li><strong>Token manipulado:</strong>
                    <ul>
                        <li>Modifica el payload en base64 (por ejemplo, cambia el rol a admin).</li>
                        <li>Verifica que la firma ya no coincida y se rechace el token.</li>
                    </ul>
                </li>
                <li><strong>Uso en múltiples servicios:</strong>
                    <ul>
                        <li>Envía el mismo token a diferentes microservicios de EcoMarket.</li>
                        <li>Comprueba que todos validan correctamente la firma.</li>
                    </ul>
                </li>
            </ol>
        </div>

        <div class="diagram">
PRUEBAS BÁSICAS DE JWT
1) Token válido
   Cliente -> API (Bearer token) -> 200 OK

2) Token expirado
   Cliente -> API (Bearer token_expirado) -> 401 Unauthorized (expirado)

3) Token manipulado
   Cliente -> API (Bearer token_tocado) -> 401 Unauthorized (firma inválida)

4) Sin token
   Cliente -> API (sin Authorization) -> 401 Unauthorized (token requerido)
        </div>

        <h3>🧪 Paso 4: Escribir Tests Automatizados</h3>
        
        <div class="tip">
            <p>Las pruebas manuales con Postman son útiles, pero los <strong>tests automatizados</strong> son esenciales para:</p>
            <ul>
                <li>Verificar que tu implementación JWT es segura</li>
                <li>Prevenir regresiones al modificar código</li>
                <li>Documentar el comportamiento esperado</li>
            </ul>
        </div>

        <div class="dual-lang">
            <div>
                <h4>Python: Tests con pytest</h4>
                <div class="code-block code-python">
<pre>import pytest
from fastapi.testclient import TestClient
import jwt
from datetime import datetime, timedelta, timezone

def test_login_genera_token_valido(client):
    """Verifica que el login devuelve un JWT válido"""
    response = client.post("/login", json={
        "email": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="98f9fcf5f1f6d8fdfbf7f5f9eaf3fdecb6fbf7f5">[email&#160;protected]</a>",
        "password": "test123"
    })
    
    assert response.status_code == 200
    assert "access_token" in response.json()
    assert "refresh_token" in response.json()
    
    # Decodificar y validar el token
    token = response.json()["access_token"]
    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    
    assert payload["role"] == "admin"
    assert "sub" in payload
    assert "exp" in payload

def test_endpoint_protegido_acepta_token_valido(client, admin_token):
    """Verifica que un endpoint protegido acepta token válido"""
    response = client.get(
        "/productos",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    assert response.status_code == 200

def test_endpoint_rechaza_sin_token(client):
    """Verifica que se rechaza petición sin token"""
    response = client.get("/productos")
    
    assert response.status_code == 401
    assert "token requerido" in response.json()["detail"].lower()

def test_endpoint_rechaza_token_expirado(client):
    """Verifica que se rechaza token expirado"""
    # Crear token que expiró hace 1 minuto
    ahora = datetime.now(timezone.utc)
    payload = {
        "sub": "user123",
        "role": "admin",
        "exp": ahora - timedelta(minutes=1)
    }
    token_expirado = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    
    response = client.get(
        "/productos",
        headers={"Authorization": f"Bearer {token_expirado}"}
    )
    
    assert response.status_code == 401
    assert "expirado" in response.json()["detail"].lower()

def test_endpoint_rechaza_token_manipulado(client):
    """Verifica que se rechaza token con firma inválida"""
    # Crear token válido
    token = crear_token("user123", "admin")
    
    # Manipular el payload (cambiar role)
    partes = token.split(".")
    import base64
    payload_modificado = base64.b64encode(
        b'{"sub":"user123","role":"superadmin"}'
    ).decode().rstrip("=")
    
    token_manipulado = f"{partes[0]}.{payload_modificado}.{partes[2]}"
    
    response = client.get(
        "/admin/usuarios",
        headers={"Authorization": f"Bearer {token_manipulado}"}
    )
    
    assert response.status_code == 401

def test_refresh_token_genera_nuevo_access(client, refresh_token):
    """Verifica que el refresh token genera un nuevo access token"""
    response = client.post("/refresh", json={
        "refresh_token": refresh_token
    })
    
    assert response.status_code == 200
    assert "access_token" in response.json()
    
    # El nuevo token debe ser diferente y válido
    nuevo_token = response.json()["access_token"]
    payload = jwt.decode(nuevo_token, SECRET_KEY, algorithms=[ALGORITHM])
    assert "sub" in payload

def test_logout_revoca_refresh_token(client, refresh_token):
    """Verifica que el logout revoca el refresh token"""
    # Primero el refresh funciona
    response1 = client.post("/refresh", json={
        "refresh_token": refresh_token
    })
    assert response1.status_code == 200
    
    # Hacer logout
    client.post("/logout", json={"refresh_token": refresh_token})
    
    # Ahora el refresh debe fallar
    response2 = client.post("/refresh", json={
        "refresh_token": refresh_token
    })
    assert response2.status_code == 401</pre>
                </div>
            </div>
            <div>
                <h4>C#: Tests con xUnit</h4>
                <div class="code-block code-csharp">
<pre>using Xunit;
using Microsoft.AspNetCore.Mvc.Testing;

public class JwtAuthTests : IClassFixture&lt;WebApplicationFactory&lt;Program&gt;&gt;
{
    private readonly HttpClient _client;

    public JwtAuthTests(WebApplicationFactory&lt;Program&gt; factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task Login_ReturnsValidJwt()
    {
        // Arrange
        var credentials = new { email = "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a5c4c1c8cccbe5c0c6cac8c4d7cec0d18bc6cac8">[email&#160;protected]</a>", password = "test123" };

        // Act
        var response = await _client.PostAsJsonAsync("/login", credentials);

        // Assert
        response.EnsureSuccessStatusCode();
        var result = await response.Content.ReadFromJsonAsync&lt;LoginResponse&gt;();
        Assert.NotNull(result.AccessToken);
        Assert.NotNull(result.RefreshToken);
    }

    [Fact]
    public async Task ProtectedEndpoint_RejectsWithoutToken()
    {
        // Act
        var response = await _client.GetAsync("/productos");

        // Assert
        Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
    }

    [Fact]
    public async Task ProtectedEndpoint_AcceptsValidToken()
    {
        // Arrange
        var token = await GetValidToken();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        // Act
        var response = await _client.GetAsync("/productos");

        // Assert
        response.EnsureSuccessStatusCode();
    }

    [Fact]
    public async Task ProtectedEndpoint_RejectsExpiredToken()
    {
        // Arrange
        var expiredToken = CreateExpiredToken();
        _client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", expiredToken);

        // Act
        var response = await _client.GetAsync("/productos");

        // Assert
        Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
    }
}</pre>
                </div>
            </div>
        </div>

        <div class="activity">
            <h3>Actividad: Implementa tu Suite de Tests</h3>
            <ol>
                <li>Instala el framework de testing:
                    <ul>
                        <li>Python: <code>pip install pytest pytest-asyncio httpx</code></li>
                        <li>C#: Ya incluido en plantillas de .NET</li>
                    </ul>
                </li>
                <li>Crea al menos <strong>5 tests</strong>:
                    <ul>
                        <li>Login exitoso devuelve token</li>
                        <li>Endpoint protegido acepta token válido</li>
                        <li>Endpoint rechaza sin token</li>
                        <li>Endpoint rechaza token expirado</li>
                        <li>Endpoint rechaza token manipulado</li>
                    </ul>
                </li>
                <li>Ejecuta los tests:
                    <ul>
                        <li>Python: <code>pytest tests/test_auth.py -v</code></li>
                        <li>C#: <code>dotnet test</code></li>
                    </ul>
                </li>
                <li>Integra los tests en tu CI/CD (GitHub Actions, GitLab CI, etc.)</li>
            </ol>
        </div>

        <div class="reflection">
            <h3>📊 Checklist de Seguridad</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Aspecto</th>
                        <th>¿Implementado?</th>
                        <th>Evidencia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Tokens tienen expiración adecuada</td>
                        <td>□ Sí / □ No</td>
                        <td>Valor <code>exp</code> configurado</td>
                    </tr>
                    <tr>
                        <td>Claves almacenadas de forma segura</td>
                        <td>□ Sí / □ No</td>
                        <td>Uso de variables de entorno / gestor de secretos</td>
                    </tr>
                    <tr>
                        <td>Roles y permisos definidos</td>
                        <td>□ Sí / □ No</td>
                        <td>Matriz de endpoints vs roles</td>
                    </tr>
                    <tr>
                        <td>Pruebas automatizadas básicas (feliz + error)</td>
                        <td>□ Sí / □ No</td>
                        <td>Scripts o colecciones Postman</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt Mejorado: Auditoría Completa de Seguridad JWT</h4>
            <pre>Actúa como un auditor de seguridad senior especializado en aplicaciones web.
Revisa mi implementación de JWT en EcoMarket:

**CONTEXTO:**
- Backend: &lt;FastAPI/ASP.NET/Spring&gt;
- Algoritmo de firma: HS256 / RS256
- Claims incluidos: sub, role, exp, iat, iss, aud, jti
- Expiración access token: 30 minutos
- Expiración refresh token: 7 días
- Almacenamiento cliente: localStorage / memoria / httpOnly cookie
- Almacenamiento clave secreta: Variable de entorno JWT_SECRET

**CÓDIGO A REVISAR:**
[Pegar aquí:]
1. Función de generación de token (login)
2. Middleware/filtro de validación
3. Endpoint de refresh (si existe)
4. Configuración de CORS

**CHECKLIST DE AUDITORÍA (revisa cada punto):**

1. **Gestión de Secretos:**
   - ¿La clave es suficientemente larga (mínimo 32 bytes)?
   - ¿Está hardcodeada o viene de variable de entorno?
   - ¿Hay rotación de claves implementada?

2. **Claims y Payload:**
   - ¿Incluye claims obligatorios (exp, iat)?
   - ¿Hay datos sensibles en el payload (contraseñas, datos financieros)?
   - ¿Falta algún claim recomendado (iss, aud, jti)?
   - ¿El claim 'sub' es inmutable (no email que puede cambiar)?

3. **Validación del Token:**
   - ¿Verifica la firma correctamente?
   - ¿Valida expiración (exp)?
   - ¿Previene el ataque "none algorithm" (verificando algoritmo)?
   - ¿Maneja todas las excepciones de JWT (ExpiredSignature, InvalidToken)?
   - ¿Valida claims como iss y aud?

4. **Almacenamiento:**
   - ¿Dónde guarda el token el frontend?
   - ¿localStorage? → Vulnerable a XSS, ¿es aceptable para este caso?
   - ¿httpOnly cookie? → ¿Tiene configuración SameSite=Strict?
   - ¿Memoria + refresh en cookie? → ¿Implementado correctamente?

5. **Refresh Tokens:**
   - ¿Existe mecanismo de refresh?
   - ¿Se pueden revocar refresh tokens (BD o Redis)?
   - ¿Hay límite de refresh tokens activos por usuario?
   - ¿Se auditan usos del refresh token?

6. **Prevención de Ataques Comunes:**
   - **Replay Attack:** ¿Hay protección (jti + revocación)?
   - **XSS:** ¿Dónde se almacena el token?
   - **CSRF:** Si usa cookies, ¿tiene SameSite?
   - **Token Sidejacking:** ¿Usa HTTPS en producción?
   - **Brute Force en login:** ¿Hay rate limiting?

7. **CORS:**
   - ¿Permite origins específicos o usa wildcard "*"?
   - ¿Permite credentials (cookies)?
   - ¿Expone headers sensibles?

**ENTREGA:**
Por favor, proporciona:
1. Lista priorizada de vulnerabilidades (crítica/alta/media/baja)
2. Para cada vulnerabilidad:
   - Línea de código específica o sección afectada
   - Explicación del riesgo
   - Solución propuesta con código ejemplo
3. 3-5 tests automatizados adicionales que debería implementar
4. Score de seguridad (0-10) con justificación

**EJEMPLO DE RESPUESTA ESPERADA:**
🔴 CRÍTICO:
- Clave secreta hardcodeada (línea 12)
- Riesgo: Compromiso total del sistema
- Solución: SECRET_KEY = os.getenv("JWT_SECRET")

🟡 MEDIO:
- No valida claim 'aud' (línea 45)
- Riesgo: Token válido usado en servicio incorrecto
- Solución: Agregar validación de audience

✅ Tests recomendados:
1. test_token_rechazado_en_servicio_incorrecto()
2. test_refresh_token_revocado_no_funciona()
3. test_rate_limiting_en_login()

Score: 6/10 - Funcional pero con gaps de seguridad importantes</pre>
        </div>

        <div class="checkpoint">
            <h3>✅ Checkpoint Final Semana 8</h3>
            <ul>
                <li>Mi API no acepta peticiones a endpoints críticos sin un JWT válido.</li>
                <li>He probado escenarios de error (expirado, manipulado, sin token).</li>
                <li>Comprendo el rol de JWT dentro de una arquitectura distribuida.</li>
                <li>Estoy preparado para, en la semana 9, integrar HTTPS/TLS y gestión de secretos para reforzar aún más la seguridad.</li>
            </ul>
        </div>
    </div>

    <!-- Rate Limiting -->
    <div class="phase" style="background: #e8f5e8;">
        <h2 data-icon="🚦">Complemento: Rate Limiting por Usuario</h2>
        
        <div class="tip">
            <h3>JWT + Rate Limiting = Protección Completa</h3>
            <p>JWT te dice <strong>quién</strong> hace la petición, pero no limita <strong>cuántas veces</strong>. Un usuario legítimo con token válido podría saturar la API (intencional o accidentalmente).</p>
            
            <h4>Estrategia de Rate Limiting Multi-Nivel:</h4>
            <ul>
                <li><strong>Por IP:</strong> 100 peticiones/minuto (protege contra ataques distribuidos)</li>
                <li><strong>Por usuario autenticado:</strong> 1000 peticiones/hora basado en claim 'sub' del JWT</li>
                <li><strong>Por endpoint crítico:</strong> Límites específicos (e.g., /login: 5 intentos/15 min)</li>
            </ul>
        </div>

        <div class="dual-lang">
            <div>
                <h4>Python con slowapi</h4>
                <div class="code-block code-python">
<pre>from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

# Limiter por IP
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Rate limit por usuario (usando JWT)
def get_user_id(request: Request):
    """Extrae user_id del JWT para rate limiting"""
    if hasattr(request.state, 'user_id'):
        return request.state.user_id
    return get_remote_address(request)

user_limiter = Limiter(key_func=get_user_id)

@app.post("/login")
@limiter.limit("5/15minutes")  # 5 intentos cada 15 minutos por IP
def login(request: Request, credenciales: Credenciales):
    # ... código de login

@app.get("/productos")
@user_limiter.limit("1000/hour")  # 1000 peticiones por hora por usuario
def listar_productos(request: Request):
    # ... código de listado</pre>
                </div>
            </div>
            <div>
                <h4>C# con AspNetCoreRateLimit</h4>
                <div class="code-block code-csharp">
<pre>// Startup.cs o Program.cs
builder.Services.AddMemoryCache();
builder.Services.Configure&lt;IpRateLimitOptions&gt;(options =>
{
    options.GeneralRules = new List&lt;RateLimitRule&gt;
    {
        new RateLimitRule
        {
            Endpoint = "*",
            Limit = 100,
            Period = "1m"
        },
        new RateLimitRule
        {
            Endpoint = "*/login",
            Limit = 5,
            Period = "15m"
        }
    };
});

// Middleware personalizado para rate limit por usuario
app.Use(async (context, next) =>
{
    if (context.User.Identity.IsAuthenticated)
    {
        var userId = context.User.FindFirst("sub")?.Value;
        // Implementar lógica de rate limiting por userId
        // usando Redis o memoria
    }
    await next();
});</pre>
                </div>
            </div>
        </div>

        <div class="activity">
            <h3>Actividad: Implementa Rate Limiting en EcoMarket</h3>
            <ol>
                <li>Instala la librería de rate limiting para tu stack.</li>
                <li>Configura límites globales por IP (100/min).</li>
                <li>Configura límites por usuario autenticado usando el claim 'sub' del JWT (1000/hora).</li>
                <li>Agrega límite estricto para el endpoint /login (5 intentos/15 min).</li>
                <li>Prueba excediendo los límites y verifica que se devuelve HTTP 429.</li>
            </ol>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="🚀">Reflexión Final: De Sistemas Escalables a Sistemas Escalables y Seguros</h2>

        <div class="reflection">
            <h3>🤔 Preguntas para Profundizar</h3>
            <ol>
                <li>¿Qué trade-offs introduces al pasar de APIs abiertas a APIs protegidas con JWT (latencia, complejidad, experiencia de desarrollo)?</li>
                <li>¿Cómo comunicarías a un stakeholder no técnico por qué JWT es una inversión necesaria para EcoMarket?</li>
                <li>Si mañana agregas un nuevo microservicio, ¿qué necesita saber para aprovechar la autenticación ya implementada?</li>
                <li>¿Qué relación ves entre JWT y los temas de la próxima semana (HTTPS, gestión de secretos, certificados)?</li>
            </ol>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt Final: Síntesis de Autenticación con JWT</h4>
            <pre>Sintetiza mi aprendizaje de la semana sobre JWT en EcoMarket:

1. Problema inicial de seguridad en mi API.
2. Cómo funciona la estructura de un JWT (header, payload, firma).
3. Decisiones que tomé (algoritmo, claims, expiración).
4. Cambios que realicé en mi código (login, middleware, roles).
5. Pruebas que hice y resultados obtenidos.
6. Qué me falta por mejorar (gestión de secretos, HTTPS, refresh tokens).

Preséntalo como un resumen técnico de media página para documentar en mi proyecto.</pre>
        </div>

        <div class="tip">
            <h3>🌟 JWT como Pieza Clave de tu Arquitectura Distribuida</h3>
            <p>Conectando con las semanas anteriores:</p>
            <ul>
                <li><strong>Semana 5-6 (Escalabilidad Horizontal):</strong> JWT permite que el load balancer distribuya peticiones sin "sticky sessions". Cualquier instancia puede validar el token sin consultar BD.</li>
                <li><strong>Semana 7 (Replicación/Sharding):</strong> Con JWT, puedes leer de cualquier réplica o shard sin coordinar sesiones centralizadas. El token ya contiene la identidad.</li>
                <li><strong>Semana 8 (Seguridad con JWT):</strong> JWT autentica y autoriza sin estado compartido. Cada servicio valida independientemente.</li>
                <li><strong>Semana 9 (HTTPS/TLS - próxima):</strong> JWT + TLS = Confidencialidad e integridad end-to-end. El token viaja cifrado por la red.</li>
            </ul>
            
            <div class="diagram">
EVOLUCIÓN: De Monolito con Sesiones a Distribuido con JWT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ANTES (Semanas 1-4):
┌──────────────────┐
│  Monolito        │
│  - Sesiones en   │
│    memoria       │
│  - No escala     │
└──────────────────┘

AHORA (Semanas 5-8):
┌─────────────────────────────────────────────────────────┐
│              Load Balancer                              │
└─────────────────────────────────────────────────────────┘
         │                 │                 │
         ▼                 ▼                 ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ Servicio 1   │  │ Servicio 2   │  │ Servicio 3   │
│ + JWT Mware  │  │ + JWT Mware  │  │ + JWT Mware  │
└──────────────┘  └──────────────┘  └──────────────┘
         │                 │                 │
         └─────────────────┴─────────────────┘
                         │
                         ▼
         ┌───────────────────────────────┐
         │  BD Replicada/Sharded         │
         │  (Semana 7)                   │
         └───────────────────────────────┘

✅ RESULTADO:
• Escalabilidad horizontal sin límites
• Seguridad distribuida (cada servicio valida)
• Alta disponibilidad (sin punto único de falla)
• Performance (stateless = sin lookups de sesión)
            </div>
            
            <p><strong>¿Por qué esto es poderoso?</strong></p>
            <ol>
                <li><strong>Stateless a nivel de aplicación:</strong> Cada instancia es intercambiable.</li>
                <li><strong>Bajo acoplamiento:</strong> Los servicios no necesitan comunicarse para validar identidad.</li>
                <li><strong>Eficiencia:</strong> Validar JWT (hash criptográfico) es órdenes de magnitud más rápido que consultar BD por cada request.</li>
                <li><strong>Escalabilidad probada:</strong> Empresas como Netflix, Uber, Airbnb usan JWT en sistemas de millones de usuarios.</li>
            </ol>
        </div>

        <div class="tip">
            <h3>🎓 Valor para tu Proyecto</h3>
            <ul>
                <li><strong>Arquitectura:</strong> Añadiste un componente de autenticación robusto a tu sistema distribuido.</li>
                <li><strong>Seguridad:</strong> Ahora puedes rastrear “quién hizo qué” y limitar el acceso por roles.</li>
                <li><strong>Escalabilidad:</strong> JWT se integra naturalmente con los servicios y técnicas de distribución vistas en semanas anteriores.</li>
                <li><strong>Preparación:</strong> Tu proyecto está listo para la siguiente capa de seguridad: comunicación cifrada (HTTPS/TLS) y gestión de secretos.</li>
              </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="🚀">Reflexión Final: De Sistemas Escalables a Sistemas Escalables y Seguros</h2>

        <div class="reflection">
            <h3>🤔 Preguntas para Profundizar</h3>
            <ol>
                <li>¿Qué trade-offs introduces al pasar de APIs abiertas a APIs protegidas con JWT (latencia, complejidad, experiencia de desarrollo)?</li>
                <li>¿Cómo comunicarías a un stakeholder no técnico por qué JWT es una inversión necesaria para EcoMarket?</li>
                <li>Si mañana agregas un nuevo microservicio, ¿qué necesita saber para aprovechar la autenticación ya implementada?</li>
                <li>¿Qué relación ves entre JWT y los temas de la próxima semana (HTTPS, gestión de secretos, certificados)?</li>
            </ol>
        </div>

        <div class="ai-prompt">
            <h4>🤖 Prompt Final: Síntesis de Autenticación con JWT</h4>
            <pre>Sintetiza mi aprendizaje de la semana sobre JWT en EcoMarket:

1. Problema inicial de seguridad en mi API.
2. Cómo funciona la estructura de un JWT (header, payload, firma).
3. Decisiones que tomé (algoritmo, claims, expiración).
4. Cambios que realicé en mi código (login, middleware, roles).
5. Pruebas que hice y resultados obtenidos.
6. Qué me falta por mejorar (gestión de secretos, HTTPS, refresh tokens).

Preséntalo como un resumen técnico de media página para documentar en mi proyecto.</pre>
        </div>

        <div class="tip">
            <h3>💡 Próximos Pasos: Semana 9</h3>
            <ul>
                <li><strong>HTTPS/TLS:</strong> Cifrar la comunicación entre cliente y servidor para proteger el token en tránsito.</li>
                <li><strong>Gestión de secretos:</strong> Usar herramientas como HashiCorp Vault, AWS Secrets Manager, o Azure Key Vault.</li>
                <li><strong>Certificados:</strong> Implementar certificados SSL/TLS y configurar renovación automática.</li>
                <li><strong>Monitoreo:</strong> Detectar intentos de autenticación fallidos, tokens expirados frecuentes, patrones de abuso.</li>
            </ul>
        </div>
    </div>
	<footer>

    <p style="margin-top: 30px;">
        🎉 ¡Excelente trabajo! Ahora no solo escalas EcoMarket, también lo proteges con autenticación basada en JWT.
    </p>
	<p>Dr Eligardo Cruz Sánchez | Programación del lado del Servidor 2025
	</p>
	</footer>
</body>
</html>